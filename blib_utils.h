#ifndef COMMON_DEFINES_H
#define COMMON_DEFINES_H
#include <stdint.h>
#include <float.h>
#define u8 uint8_t
#define u16 uint16_t
#define u32 uint32_t
#define i16 int16_t
#define i32 int32_t

#define i64 int64_t
#define b32 uint32_t
#define u64 uint64_t
#define r32 float
#define r64 double
#define NUM_WORKER_THREADS (1)
#define DEFAULT_ENTITIES 256
#define B32_TRUE 1;
#define B32_FALSE 0;
#define flocal static
#define global_variable static
#define persist static
#define U32_MAX UINT32_MAX
#define U64_MAX UINT64_MAX
#define R32_MAX FLT_MAX
#define NULL_TERMINATOR '\0'

#define STRINGIFY(s) #s

#define PI(number) ((number)*3.14159265359f)
#define SQ(number) ((number) * (number))
#define CUBE(number) ((number) * (number) * (number))
#define MAX_VEC (v(R32_MAX, R32_MAX, R32_MAX))

#define SCL 5
#define MAX_VEC2 (v(R32_MAX, R32_MAX))
#define MAX_V2 MAX_VEC2
#define RADIANS(DEGREES) (DEGREES * (PI(1) / 180.0f))
#define DEGREES(RADIANS) (RADIANS * (180.0f / PI(1)))

#define KILOBYTES(number) ((number)*1024)
#define MEGABYTES(number) ((KILOBYTES(number) * 1024))
#define GIGABYTES(number) ((MEGABYTES(number) * 1024))

#define ACCESS_PTR(ptr, idx, type) (&(((type *)ptr)[idx]))
#define ACCESS_VAL(ptr, idx, type) (((type *)(ptr))[idx])
#define ASSIGN_PTR(ptr, val) \
    if ((ptr))               \
    {                        \
        *ptr = (val);        \
    }

//Only works for constant arrays, not pointers
#define arrayCount(array) (sizeof(array) / sizeof(array[0]))
#if DEBUG == 1
#define ASSERT(expr, text)                                       \
    if (!(expr))                                                 \
    {                                                            \
        fprintf(stderr, "%s %s %d\n", text, __FILE__, __LINE__); \
        *(int *)0 = 0;                                           \
    }
#else
#define ASSERT(expr, text) expr
#endif

#define LOOP(induction, end) for (u32 induction = 0; induction < end; induction++)
#define POOL(induction, initial) for (u32 induction = initial; induction >= 0; induction--)

#ifdef ALIGN_MEMORY
#define malloc(num) _aligned_malloc(num, 16)
#define free(ptr) _aligned_free(ptr)
#endif

#if 0 
void* safe_realloc(void* src, size_t size, size_t original)
{

    void* tmp = realloc((u8*)src, size);
    if (tmp)
    {
        return tmp;
    }
    else
    {
        ASSERT(1==0, "Realloc failed: ");
        return nullptr;
    }
}

#define realloc safe_realloc
#endif
#if 0
#include <stdio.h>
#include <malloc.h>
void* report_malloc(size_t size, char* file, u32 line)
{
    printf("Malloc at %s line %d\n",file, line);
    return malloc(size);
}
#define malloc(size) report_malloc((size), __FILE__, __LINE__)
#endif

/**
 *Dumb way of testing string equivalence, with a length specifier.
 *Unlikely to be optimal, must check whether sse instructions are being generated by compiler
 */
b32 streq(char *a, char *b, u32 b_len)
{
    LOOP(i, b_len)
    {
        if (a[i] != b[i])
        {
            return false;
        }
    }
    return true;
}

/**
 *Used to swap the values of two uint32_t pointers
 */
flocal inline void swap(u32 *a, u32 *b)
{
    u32 swp = *a;
    *a = *b;
    *b = swp;
}

#endif // !COMMON_DEFINES_H
